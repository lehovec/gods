// Package implements differential synchronization method by N. Fraser
// For more info please visit: https://neil.fraser.name/writing/sync/
package gods

import (
	"github.com/sergi/go-diff/diffmatchpatch"
	"fmt"
	"errors"
)

// -- STORAGE ----------------------------------

var diffmp *diffmatchpatch.DiffMatchPatch = diffmatchpatch.New() // stateless lib

// Constant is standard document type send to Get or Set method in storage
const DOCTYPE_DOCUMENT = 1;
// Constant is shadow type document send to Get or Set method in storage
const DOCTYPE_SHADOW = 2;
// Constant is backup document send to Get or Set method in storage
const DOCTYPE_BACKUP = 4;


// Storage interface provide methods to save and load documents created by Differential Synchronization
// You can create different kinds of storages for save and load from file, DB or eg. web...
// Storage function should return error!
type Storage interface {
	// Get document from storage by id
	Get(docType int, connId interface{}) (string, error)
	// Set document to storage by id
	Set(docType int, connId interface{}, text string) error
}

// Default Storage interface implementation, save document to variables (arrays)
type MemoryStorage struct {
	memoryDocument             string
	memoryShadow, memoryBackup map[interface{}]string
}

// Create new memory storage
func NewMemoryStorage() *MemoryStorage {
	return &MemoryStorage{memoryShadow: make(map[interface{}]string), memoryBackup: make(map[interface{}]string)}
}

func (storage *MemoryStorage) Get(docType int, id interface{}) (string, error) {
	notFoundErr := errors.New("Document doesn't exists for this id");
	text, ok := "", false
	if docType == DOCTYPE_DOCUMENT {
		text, ok = storage.memoryDocument, true
	}else if docType == DOCTYPE_SHADOW {
		text, ok = storage.memoryShadow[id]
	}else if docType == DOCTYPE_BACKUP {
		text, ok = storage.memoryBackup[id]
	}
	if ok {
		return text, nil
	}
	return text, notFoundErr
}

func (storage *MemoryStorage) Set(docType int, id interface{}, text string) error {
	switch docType {
	case DOCTYPE_DOCUMENT: storage.memoryDocument = text
	case DOCTYPE_SHADOW: storage.memoryShadow[id] = text
	case DOCTYPE_BACKUP: storage.memoryBackup[id] = text
	}
	return nil
}

// ---------------------------------------------

// -- CONNECTIONS ------------------------------

type versions struct {
	server, client, backup int
}

type connection struct {
	//shadow, backup string
	version  versions
	stack    []DSPatch
	isClient bool
}

func (conn *connection) raiseDiffVersion() int {
	if conn.isClient {
		conn.version.client += 1
		return conn.version.client
	}
	conn.version.server += 1
	return conn.version.server
}

func (conn *connection) raisePatchVersion() int {
	if conn.isClient {
		conn.version.server += 1
		return conn.version.server
	}
	conn.version.client += 1
	return conn.version.client
}

func (conn *connection) cleanStack(lastVersion int) {
	var newStack []DSPatch

	for i, patch := range conn.stack {

		patchVersion := patch.Version.server
		if conn.isClient {
			patchVersion = patch.Version.client
		}

		if patchVersion <= lastVersion {
			if i + 1 < cap(conn.stack) {
				newStack = append(conn.stack[:i], conn.stack[i+1:]...)
			} else {
				newStack = conn.stack[:i]
			}
		}
	}
	conn.stack = newStack
}

// ---------------------------------------------

// -- SYNCHRONIZATION --------------------------

// Patch object, represents patch uses in Differential Synchronization
// Patch contains diff generated by diff algoritm and versions of documents uses in synchronization cycle
type DSPatch struct {
	Diffs   []diffmatchpatch.Patch // Slice of patches generated by diff patch match algorithm (see http://github.com/sergi/go-diff/diffmatchpatch)
	Version versions               // This struct contains versions of patches
}

type GoDS struct {
	connections map[interface{}]*connection
	storage     Storage
}

func (gods *GoDS) getDoc(connId interface{}) (string, error) {
	doc, err := gods.storage.Get(DOCTYPE_DOCUMENT, connId)
	return doc, err
}

func (gods *GoDS) getShadow(connId interface{}) (string, error) {
	doc, err := gods.storage.Get(DOCTYPE_SHADOW, connId)
	return doc, err
}

func (gods *GoDS) getBackup(connId interface{}) (string, error) {
	doc, err := gods.storage.Get(DOCTYPE_BACKUP, connId)
	return doc, err
}

func (gods *GoDS) setDoc(connId interface{}, document string) error {
	err := gods.storage.Set(DOCTYPE_DOCUMENT, connId, document)
	return err
}

func (gods *GoDS) setShadow(connId interface{}, document string) error {
	err := gods.storage.Set(DOCTYPE_SHADOW, connId, document)
	return err
}

func (gods *GoDS) setBackup(connId interface{}, shadowLocal string) error {
	err := gods.storage.Set(DOCTYPE_BACKUP, connId, shadowLocal)
	return err
}

// Method return patch array which receive ApplyPatch method
// Method property receive connection id provided in AddClientConnection or AddServerConnection methods
func (gods *GoDS) GetPatch(connId  interface{}) ([]DSPatch, error) {
	conn, exists := gods.connections[connId]
	if !exists {
		return nil, errors.New("Connection does't exitst")
	}

	document, err := gods.getDoc(connId)
	if err != nil { return nil, err }

	shadow, err := gods.getShadow(connId)
	diff := diffmp.PatchMake(shadow, document)

	patch := DSPatch{Diffs: diff, Version: versions{}}
	patch.Version.server = conn.version.server
	patch.Version.client = conn.version.client
	conn.stack = append(conn.stack, patch)

	if gods.setShadow(connId, document) != nil { return nil, err }
	conn.raiseDiffVersion()
	return conn.stack, nil
}

// Receive patches and return patched document
// First method property receive array of DSPatch object generated by GetPatch method
// Second method property receive connection id provided in AddClientConnection or AddServerConnection methods
func (gods *GoDS) ApplyPatch(patches []DSPatch, connId interface{}) (string, error) {
	conn, exists := gods.connections[connId]
	if !exists {
		return "", errors.New("Connection does't exitst")
	}
	var documentLocal string
	for _, patch := range patches {

		patchVersion := patch.Version.server
		connVersion := conn.version.server
		if conn.isClient {
			patchVersion = patch.Version.client
			connVersion = conn.version.client
		}
		conn.cleanStack(connVersion)
		if patchVersion == connVersion {

			shadow, err := gods.getShadow(connId)
			if err != nil { return "", err }

			shadowLocal, _ := diffmp.PatchApply(patch.Diffs, shadow)
			conn.raisePatchVersion()

			err = gods.setBackup(connId, shadowLocal)
			if err != nil { return "", err }

			conn.version.backup = patchVersion
			document, err := gods.getDoc(connId)
			if err != nil { return "", err }

			documentLocal, _ = diffmp.PatchApply(patch.Diffs, document)

			gods.setDoc(connId, documentLocal)
			gods.setShadow(connId, shadowLocal)

		} else if conn.version.backup == patch.Version.client {
			backup, err := gods.getBackup(connId)
			if err != nil { return "", err }

			err = gods.setShadow(connId, backup)
			if err != nil { return "", err }

			fmt.Println("Version doesn't match, load backup")
		} else {
			document, err := gods.getDoc(connId)
			if err != nil { return "", err }
			return document, errors.New("Fatal error. Cannot synchronize")
		}
	}
	document, err := gods.getDoc(connId)
	if err != nil { return "", err }
	return document, nil
}

// Create new server connection for GoDS object which represent server
func (gods *GoDS) AddServerConnection(key interface{}) {
	gods.addConnection(key, false)
	doc, err := gods.getDoc(key);
	if (err != nil) {
		gods.setDoc(key, "")
		doc = ""
	}
	gods.setShadow(key, doc);
	gods.setBackup(key, doc);
}

// Create new client connection for GoDS object which represent client
func (gods *GoDS) AddClientConnection(key interface{}) {
	gods.addConnection(key, true)
	doc, err := gods.getDoc(key);
	if (err != nil) {
		gods.setDoc(key, "")
		doc = ""
	}
	gods.setShadow(key, doc);
	gods.setBackup(key, doc);
}

func (gods *GoDS) addConnection(key interface{}, isClient bool) {
	gods.connections[key] = &connection{stack: make([]DSPatch, 0, 32), isClient: isClient} // TODO: add checker to too big stack
}

// Inicialize new differential synchronization object
func New() *GoDS {
	return &GoDS{make(map[interface{}]*connection), new(MemoryStorage)}
}

// Set synchronization storage
func (gods *GoDS) SetStorage(storage Storage) *GoDS {
	gods.storage = storage
	return gods
}

// ---------------------------------------------
